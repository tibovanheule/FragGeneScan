.TH "src/util_lib.c" 3 "Vr 12 Jun 2020" "Version 0.1" "FragScanTibo" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/util_lib.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'util_lib\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTR_SIZE\fP   14"
.br
.in -1c
.SS "Functies"

.in +1c
.ti -1c
.RI "double \fBlog2\fP (double a)"
.br
.ti -1c
.RI "double ** \fBdmatrix\fP (int num_row, int num_col)"
.br
.ti -1c
.RI "int ** \fBimatrix\fP (int num_row, int num_col)"
.br
.ti -1c
.RI "double * \fBdvector\fP (int nh)"
.br
.ti -1c
.RI "int * \fBivector\fP (int nh)"
.br
.ti -1c
.RI "void \fBfree_dvector\fP (double *v)"
.br
.ti -1c
.RI "void \fBfree_ivector\fP (int *v)"
.br
.ti -1c
.RI "void \fBfree_dmatrix\fP (double **m, int num_row)"
.br
.ti -1c
.RI "void \fBfree_imatrix\fP (int **m, int num_row)"
.br
.ti -1c
.RI "int \fBtr2int\fP (char *tr)"
.br
.ti -1c
.RI "int \fBnt2int\fP (char nt)"
.br
.ti -1c
.RI "int \fBnt2int_rc\fP (char nt)"
.br
.ti -1c
.RI "int \fBnt2int_rc_indel\fP (char nt)"
.br
.ti -1c
.RI "int \fBtrinucleotide\fP (char a, char b, char c)"
.br
.ti -1c
.RI "int \fBtrinucleotide_pep\fP (char a, char b, char c)"
.br
.ti -1c
.RI "void \fBget_rc_dna\fP (char *dna, char *dna1)"
.br
.ti -1c
.RI "void \fBget_rc_dna_indel\fP (char *dna, char *dna1)"
.br
.ti -1c
.RI "void \fBget_protein\fP (char *dna, char *protein, int strand, int whole_genome)"
.br
.ti -1c
.RI "void \fBprint_usage\fP ()"
.br
.ti -1c
.RI "void \fBprint_allocation_error\fP (const char *format,\&.\&.\&.)"
.br
.in -1c
.SS "Variabelen"

.in +1c
.ti -1c
.RI "char * \fBtr_list\fP [\fBTR_SIZE\fP] = { 'MM','MI','MD','II','IM','DD','DM','GE','GG','ER','RS','RR','ES','ES1' }"
.br
.ti -1c
.RI "char \fBcodon5\fP [5] = { '\fBA\fP', '\fBC\fP', '\fBG\fP', '\fBT\fP', 'N' }"
.br
.ti -1c
.RI "char \fBcodon11\fP [11] = { '\fBA\fP', '\fBC\fP', '\fBG\fP', '\fBT\fP', 'N', 'a', 'c', 'g', 't', 'n', 'x' }"
.br
.ti -1c
.RI "char \fBcodon_code\fP [65]"
.br
.ti -1c
.RI "char \fBanti_codon_code\fP [65]"
.br
.in -1c
.SH "Documentatie van macro's"
.PP 
.SS "#define TR_SIZE   14"

.SH "Documentatie van functies"
.PP 
.SS "double** dmatrix (int num_row, int num_col)"
Makes an matrix with datatype double\&. Elements are double pointers en matrix is a double double pointer (**pointer)\&. Exits when allocation fails\&. 
.SS "double* dvector (int nh)"
Makes an vector (array) with datatype double\&. Elements are doubles en vector is a double pointer\&. Exits when allocation fails\&. 
.SS "void free_dmatrix (double ** m, int num_row)"
Frees the memory allocation of an matrix with datatype double\&. 
.SS "void free_dvector (double * v)"
Frees the memory allocation of an vector with datatype double\&. 
.SS "void free_imatrix (int ** m, int num_row)"
Frees the memory allocation of an matrix with datatype int\&. 
.SS "void free_ivector (int * v)"
Frees the memory allocation of an vector with datatype int\&. 
.SS "void get_protein (char * dna, char * protein, int strand, int whole_genome)"
Get a protein of dna if Whole_genome equals to zero, then we want a short read and stop early\&. 
.SS "void get_rc_dna (char * dna, char * dna1)"
copies dna to dna1 in reverse\&. and 
.SS "void get_rc_dna_indel (char * dna, char * dna1)"
copies dna to dna1 in reverse\&. and 
.SS "int** imatrix (int num_row, int num_col)"
Makes an matrix with datatype int\&. Elements are int pointers en matrix is a double int pointer\&. Exits when allocation fails\&. 
.SS "int* ivector (int nh)"
Makes an vector array) with datatype int\&. Elements are ints en vector is a int pointer\&. Exits when allocation fails\&. 
.SS "double log2 (double a)"

.SS "int nt2int (char nt)"

.SS "int nt2int_rc (char nt)"

.SS "int nt2int_rc_indel (char nt)"

.SS "void print_allocation_error (const char * format,  \&.\&.\&.)"
Custom error function to print allocation errors\&. Mostly called from matrix or vector functions\&. 
.SS "void print_usage ()"
Print how the program should be used\&. called mainly on help or error\&. 
.SS "int tr2int (char * tr)"
Converts a given transition to int\&. Use for example as indexing\&. switch case not possible due the fact that strings are not constonant\&. 
.SS "int trinucleotide (char a, char b, char c)"

.SS "int trinucleotide_pep (char a, char b, char c)"

.SH "Documentatie van variabelen"
.PP 
.SS "char anti_codon_code[65]"
\fBInitie\*(4le waarde:\fP
.PP
.nf
= { 'F','V','L','I',
                             'C','G','R','S',
                             'S','A','P','T',
                             'Y','D','H','N',
                             'L','V','L','M',
                             'W','G','R','R',
                             'S','A','P','T',
                             '*','E','Q','K',
                             'F','V','L','I',
                             'C','G','R','S',
                             'S','A','P','T',
                             'Y','D','H','N',
                             'L','V','L','I',
                             '*','G','R','R',
                             'S','A','P','T',
                             '*','E','Q','K','X'
                           }
.fi
.SS "char codon11[11] = { '\fBA\fP', '\fBC\fP', '\fBG\fP', '\fBT\fP', 'N', 'a', 'c', 'g', 't', 'n', 'x' }"

.SS "char codon5[5] = { '\fBA\fP', '\fBC\fP', '\fBG\fP', '\fBT\fP', 'N' }"

.SS "char codon_code[65]"
\fBInitie\*(4le waarde:\fP
.PP
.nf
= { 'K','N','K','N',
                        'T','T','T','T',
                        'R','S','R','S',
                        'I','I','M','I',
                        'Q','H','Q','H',
                        'P','P','P','P',
                        'R','R','R','R',
                        'L','L','L','L',
                        'E','D','E','D',
                        'A','A','A','A',
                        'G','G','G','G',
                        'V','V','V','V',
                        '*','Y','*','Y',
                        'S','S','S','S',
                        '*','C','W','C',
                        'L','F','L','F', 'X'
                      }
.fi
.SS "char* tr_list[\fBTR_SIZE\fP] = { 'MM','MI','MD','II','IM','DD','DM','GE','GG','ER','RS','RR','ES','ES1' }"

.SH "Auteur"
.PP 
Automatisch gegenereerd door Doxygen voor FragScanTibo uit de programmatekst\&.
